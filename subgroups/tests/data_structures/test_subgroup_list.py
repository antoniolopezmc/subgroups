# -*- coding: utf-8 -*-

# Contributors:
#    Antonio López Martínez-Carrasco <antoniolopezmc1995@gmail.com>

"""Tests of the functionality contained in the file 'data_structures/subgroup_list.py'.
"""

from subgroups.data_structures.subgroup_list import SubgroupList
from subgroups.core.operator import Operator
from subgroups.core.selector import Selector
from subgroups.core.pattern import Pattern
from subgroups.core.subgroup import Subgroup
from pandas import DataFrame
from bitarray import bitarray
import unittest

class TestSubgroupList(unittest.TestCase):

    def test_subgroup_list_1(self) -> None:
        self.assertRaises(TypeError, SubgroupList, bitarray("10110"), "a", 5)
        self.assertRaises(TypeError, SubgroupList, "a", bitarray("01001"), 5)
        self.assertRaises(TypeError, SubgroupList, bitarray("10110"), bitarray("01001"), "a")
        self.assertRaises(ValueError, SubgroupList, bitarray("10110"), bitarray("01001"), 50)
        self.assertRaises(ValueError, SubgroupList, bitarray("1011"), bitarray("01001"), 50)
        self.assertRaises(ValueError, SubgroupList, bitarray("10110"), bitarray("0100"), 50)
        self.assertRaises(ValueError, SubgroupList, bitarray("1011"), bitarray("01001"), 5)
        self.assertRaises(ValueError, SubgroupList, bitarray("10110"), bitarray("0100"), 5)
        SubgroupList(bitarray("10110"), bitarray("01001"), 5) # This must not raise an exception.

    def test_subgroup_list_2(self) -> None:
        df = DataFrame({"at1" : ["a", "a", "d", "a", "a"], "at2" : ["b", "c", "c", "e", "b"], "target" : ["y", "n", "y", "y", "n"]})
        dataset_target_bitarray_of_positives = bitarray("10110") # Only the target, considering the complete dataset.
        dataset_target_bitarray_of_negatives = bitarray("01001") # Only the target, considering the complete dataset.
        ## Empty subgroup list.
        sl = SubgroupList(dataset_target_bitarray_of_positives, dataset_target_bitarray_of_negatives, len(df))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("10110"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("01001"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, dataset_target_bitarray_of_positives)
        self.assertEqual(sl.default_rule_bitarray_of_negatives, dataset_target_bitarray_of_negatives)
        self.assertNotEqual(id(sl.default_rule_bitarray_of_positives), id(dataset_target_bitarray_of_positives))
        self.assertNotEqual(id(sl.default_rule_bitarray_of_negatives), id(dataset_target_bitarray_of_negatives))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 0)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertTrue(sl.is_empty())
        self.assertRaises(IndexError, sl.get_subgroup, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 0)
        sl.delete_last_subgroup() # The subgroup list is empty. This method does nothig.
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("10110"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("01001"))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 0)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertTrue(sl.is_empty())
        self.assertRaises(IndexError, sl.get_subgroup, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 0)
        ## Add s1 at the end of the subgroup list (and before the default rule).
        s1 = Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("10010") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("01001") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s1, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(s1, sl.get_subgroup(0))
        self.assertNotEqual(id(s1), id(sl.get_subgroup(0)))
        self.assertEqual(bitarray_of_positives, bitarray("10010"))
        self.assertEqual(bitarray_of_negatives, bitarray("01001"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("00100"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("00000"))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 1)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a")]), Selector("target", Operator.EQUAL, "y")))
        # In this case, the bitarray considering the complete dataset and the bitarray considering the position of the subgroup in the list are
        #   equal because it is the first subgroup in the list.
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("10010"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("01001"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(0)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(0)))
        self.assertRaises(IndexError, sl.get_subgroup, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 1)
        ## Add s2 at the end of the subgroup list (and before the default rule).
        s2 = Subgroup(Pattern([Selector("at2", Operator.EQUAL, "c")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("00100") # Pattern and target (i.e., the subgroup) considering the complete dataset.
        bitarray_of_negatives = bitarray("01000") # Pattern and target (i.e., the subgroup) considering the complete dataset.
        sl.add_subgroup(s2, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("00100"))
        self.assertEqual(bitarray_of_negatives, bitarray("01000"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("00000"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("00000"))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 2)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("10010"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("01001"))
        self.assertEqual(sl.get_subgroup(1), s2)
        self.assertEqual(sl.get_subgroup(1), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "c")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(1), bitarray("00100"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(1), bitarray("00000"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(1)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(1)))
        self.assertRaises(IndexError, sl.get_subgroup, 2)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 2)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 2)
        ## Delete the last subgroup.
        sl.delete_last_subgroup()
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("00100"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("00000"))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 1)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("10010"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("01001"))
        self.assertFalse(sl.is_empty())
        self.assertRaises(IndexError, sl.get_subgroup, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 1)

    def test_subgroup_list_3(self) -> None:
        df = DataFrame({"at1" : ["a", "a", "d", "a", "x", "e", "x"], \
                        "at2" : ["b", "w", "b", "b", "w", "b", "w"], \
                        "at3" : ["c", "z", "c", "c", "z", "c", "c"], \
                        "target" : ["y", "n", "y", "n", "y", "n", "n"]})
        dataset_target_bitarray_of_positives = bitarray("1010100") # Only the target, considering the complete dataset.
        dataset_target_bitarray_of_negatives = bitarray("0101011") # Only the target, considering the complete dataset.
        ## Empty subgroup list.
        sl = SubgroupList(dataset_target_bitarray_of_positives, dataset_target_bitarray_of_negatives, len(df))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("1010100"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0101011"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, dataset_target_bitarray_of_positives)
        self.assertEqual(sl.default_rule_bitarray_of_negatives, dataset_target_bitarray_of_negatives)
        self.assertNotEqual(id(sl.default_rule_bitarray_of_positives), id(dataset_target_bitarray_of_positives))
        self.assertNotEqual(id(sl.default_rule_bitarray_of_negatives), id(dataset_target_bitarray_of_negatives))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 0)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertTrue(sl.is_empty())
        self.assertRaises(IndexError, sl.get_subgroup, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 0)
        ## Add s1 at the end of the subgroup list (and before the default rule).
        s1 = Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("1000000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("0001000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s1, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("1000000"))
        self.assertEqual(bitarray_of_negatives, bitarray("0001000"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("0010100"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0100011"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 1)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        # In this case, the bitarray considering the complete dataset and the bitarray considering the position of the subgroup in the list are
        #   equal because it is the first subgroup in the list.
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("1000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("0001000"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(0)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(0)))
        self.assertRaises(IndexError, sl.get_subgroup, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 1)
        ## Delete the last subgroup.
        sl.delete_last_subgroup()
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("1010100"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0101011"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 0)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertTrue(sl.is_empty())
        self.assertRaises(IndexError, sl.get_subgroup, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 0)
        ## Add s1 at the end of the subgroup list (and before the default rule).
        s1 = Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("1000000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("0001000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s1, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("1000000"))
        self.assertEqual(bitarray_of_negatives, bitarray("0001000"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("0010100"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0100011"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 1)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("1000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("0001000"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(0)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(0)))
        self.assertRaises(IndexError, sl.get_subgroup, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 1)
        ## Add s2 at the end of the subgroup list (and before the default rule).
        s2 = Subgroup(Pattern([Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("1010000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("0001010") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s2, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("1010000"))
        self.assertEqual(bitarray_of_negatives, bitarray("0001010"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("0000100"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0100001"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 2)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("1000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("0001000"))
        self.assertEqual(sl.get_subgroup(1), s2)
        self.assertEqual(sl.get_subgroup(1), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(1), bitarray("0010000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(1), bitarray("0000010"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(1)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(1)))
        self.assertRaises(IndexError, sl.get_subgroup, 2)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 2)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 2)
        ## Add s3 at the end of the subgroup list (and before the default rule).
        s3 = Subgroup(Pattern([Selector("at3", Operator.EQUAL, "z")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("0000100") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("0100000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s3, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("0000100"))
        self.assertEqual(bitarray_of_negatives, bitarray("0100000"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("0000000"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0000001"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 3)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("1000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("0001000"))
        self.assertEqual(sl.get_subgroup(1), s2)
        self.assertEqual(sl.get_subgroup(1), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(1), bitarray("0010000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(1), bitarray("0000010"))
        self.assertEqual(sl.get_subgroup(2), s3)
        self.assertEqual(sl.get_subgroup(2), Subgroup(Pattern([Selector("at3", Operator.EQUAL, "z")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(2), bitarray("0000100"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(2), bitarray("0100000"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(2)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(2)))
        self.assertRaises(IndexError, sl.get_subgroup, 3)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 3)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 3)
        ## Add s3 again (i.e., the same subgroup repeated twice).
        s3 = Subgroup(Pattern([Selector("at3", Operator.EQUAL, "z")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("0000100") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("0100000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s3, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("0000100"))
        self.assertEqual(bitarray_of_negatives, bitarray("0100000"))
        # The default rule is the same, because the "new" subgroup in the list is not covering new rows. 
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("0000000"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0000001"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 4)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("1000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("0001000"))
        self.assertEqual(sl.get_subgroup(1), s2)
        self.assertEqual(sl.get_subgroup(1), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(1), bitarray("0010000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(1), bitarray("0000010"))
        self.assertEqual(sl.get_subgroup(2), s3)
        self.assertEqual(sl.get_subgroup(2), Subgroup(Pattern([Selector("at3", Operator.EQUAL, "z")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(2), bitarray("0000100"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(2), bitarray("0100000"))
        self.assertEqual(sl.get_subgroup(3), s3)
        self.assertEqual(sl.get_subgroup(3), Subgroup(Pattern([Selector("at3", Operator.EQUAL, "z")]), Selector("target", Operator.EQUAL, "y")))
        # In this case, both bitarrays only contains 0s, because all rows covered by this subgroup were already covered before.
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(3), bitarray("0000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(3), bitarray("0000000"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(3)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(3)))
        self.assertRaises(IndexError, sl.get_subgroup, 4)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 4)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 4)
        ## Delete the last subgroup (i.e., delete the repeated subgroup).
        sl.delete_last_subgroup()
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("0000000"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0000001"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 3)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("1000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("0001000"))
        self.assertEqual(sl.get_subgroup(1), s2)
        self.assertEqual(sl.get_subgroup(1), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(1), bitarray("0010000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(1), bitarray("0000010"))
        self.assertEqual(sl.get_subgroup(2), s3)
        self.assertEqual(sl.get_subgroup(2), Subgroup(Pattern([Selector("at3", Operator.EQUAL, "z")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(2), bitarray("0000100"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(2), bitarray("0100000"))
        self.assertFalse(sl.is_empty())
        self.assertRaises(IndexError, sl.get_subgroup, 3)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 3)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 3)
        ## Add s4 at the end of the subgroup list (and before the default rule).
        s4 = Subgroup(Pattern([Selector("at2", Operator.EQUAL, "w")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("0000100") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("0100001") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s4, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("0000100"))
        self.assertEqual(bitarray_of_negatives, bitarray("0100001"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("0000000"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("0000000"))
        self.assertEqual(sl.dataset_target_distribution, 3/7)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 4)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 7)
        self.assertEqual(len(sl), 4)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a"), Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("1000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("0001000"))
        self.assertEqual(sl.get_subgroup(1), s2)
        self.assertEqual(sl.get_subgroup(1), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "b")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(1), bitarray("0010000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(1), bitarray("0000010"))
        self.assertEqual(sl.get_subgroup(2), s3)
        self.assertEqual(sl.get_subgroup(2), Subgroup(Pattern([Selector("at3", Operator.EQUAL, "z")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(2), bitarray("0000100"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(2), bitarray("0100000"))
        self.assertEqual(sl.get_subgroup(3), s4)
        self.assertEqual(sl.get_subgroup(3), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "w")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(3), bitarray("0000000"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(3), bitarray("0000001"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(3)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(3)))
        self.assertRaises(IndexError, sl.get_subgroup, 4)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 4)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 4)

    def test_subgroup_list_4(self) -> None:
        df = DataFrame({"at1" : ["a", "a", "a", "b", "b"], \
                        "at2" : ["q", "s", "r", "s", "s"], \
                        "at3" : ["x", "w", "x", "w", "z"], \
                        "target" : ["yes", "no", "yes", "yes", "maybe"]})
        # IMPORTANT: "maybe" is not the target, therefore, it is also negative (along with "no").
        dataset_target_bitarray_of_positives = bitarray("10110") # Only the target, considering the complete dataset.
        dataset_target_bitarray_of_negatives = bitarray("01001") # Only the target, considering the complete dataset.
        ## Empty subgroup list.
        sl = SubgroupList(dataset_target_bitarray_of_positives, dataset_target_bitarray_of_negatives, len(df))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("10110"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("01001"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, dataset_target_bitarray_of_positives)
        self.assertEqual(sl.default_rule_bitarray_of_negatives, dataset_target_bitarray_of_negatives)
        self.assertNotEqual(id(sl.default_rule_bitarray_of_positives), id(dataset_target_bitarray_of_positives))
        self.assertNotEqual(id(sl.default_rule_bitarray_of_negatives), id(dataset_target_bitarray_of_negatives))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 0)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertTrue(sl.is_empty())
        self.assertRaises(IndexError, sl.get_subgroup, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 0)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 0)
        ## Add s1 at the end of the subgroup list (and before the default rule).
        s1 = Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("10100") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("01000") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s1, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("10100"))
        self.assertEqual(bitarray_of_negatives, bitarray("01000"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("00010"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("00001"))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 1)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("10100"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("01000"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(0)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(0)))
        self.assertRaises(IndexError, sl.get_subgroup, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 1)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 1)
        ## Add s2 at the end of the subgroup list (and before the default rule).
        s2 = Subgroup(Pattern([Selector("at2", Operator.EQUAL, "s")]), Selector("target", Operator.EQUAL, "y"))
        bitarray_of_positives = bitarray("00010") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        bitarray_of_negatives = bitarray("01001") # Pattern and target (i.e., the subgroup), considering the complete dataset.
        sl.add_subgroup(s2, bitarray_of_positives, bitarray_of_negatives)
        self.assertEqual(bitarray_of_positives, bitarray("00010"))
        self.assertEqual(bitarray_of_negatives, bitarray("01001"))
        self.assertEqual(sl.default_rule_bitarray_of_positives, bitarray("00000"))
        self.assertEqual(sl.default_rule_bitarray_of_negatives, bitarray("00000"))
        self.assertEqual(sl.dataset_target_distribution, 3/5)
        self.assertEqual(sl.dataset_number_of_positives, 3)
        self.assertEqual(sl.dataset_number_of_negatives, 2)
        self.assertEqual(sl.number_of_dataset_instances, len(df))
        self.assertEqual(sl.number_of_dataset_instances, 5)
        self.assertEqual(len(sl), 2)
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_positives))
        self.assertEqual(len(sl), len(sl._subgroups_bitarrays_of_negatives))
        self.assertEqual(sl.get_subgroup(0), s1)
        self.assertEqual(sl.get_subgroup(0), Subgroup(Pattern([Selector("at1", Operator.EQUAL, "a")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(0), bitarray("10100"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(0), bitarray("01000"))
        self.assertEqual(sl.get_subgroup(1), s2)
        self.assertEqual(sl.get_subgroup(1), Subgroup(Pattern([Selector("at2", Operator.EQUAL, "s")]), Selector("target", Operator.EQUAL, "y")))
        self.assertEqual(sl.get_subgroup_bitarray_of_positives(1), bitarray("00010"))
        self.assertEqual(sl.get_subgroup_bitarray_of_negatives(1), bitarray("00001"))
        self.assertFalse(sl.is_empty())
        self.assertNotEqual(id(bitarray_of_positives), id(sl.get_subgroup_bitarray_of_positives(1)))
        self.assertNotEqual(id(bitarray_of_negatives), id(sl.get_subgroup_bitarray_of_negatives(1)))
        self.assertRaises(IndexError, sl.get_subgroup, 2)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_positives, 2)
        self.assertRaises(IndexError, sl.get_subgroup_bitarray_of_negatives, 2)
